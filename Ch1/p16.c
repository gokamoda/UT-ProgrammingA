/*
カプレカー変換
  ある自然数に対するカプレカ―変換は，以下の手順で定義される．

  自然数の桁の数字を大きい順に並び替え，その桁数字を用いてできる最大の自然数を作る
  自然数の桁の数字を小さい順に並び替え，その桁数字を用いてできる最小の自然数を作る
  最大の自然数（手順1）から最小の自然数（手順2）を引き，自然数を更新する
  3桁の自然数（ただし全ての桁の数字が同じものは除く）に対して，
  カプレカ―変換を繰り返し適用すると，
  必ず495に到達することが知られている．
  例えば，246を出発点とすると，以下のように495に到達する．

  642−246=396
  963−369=594
  954−459=495

問題
  標準入力より3桁までの自然数を読み込み，495に到達するまでカプレカ―変換を繰り返すプログラムを作成せよ．

  プログラムは以下の仕様を満たすこと．

  各行に1回のカプレカー変換の様子を「最大の自然数 - 最小の自然数 = 新しい自然数」という形式で出力すること．
  実行例を参考にせよ．
  3桁に満たない数字については上位の桁が0で埋められていると考える．
  たとえば909に対するカプレカー変換は909↦990−99=891であり，9に対するカプレカー変換は9↦900−9=891である．
  各自然数は右詰めで3桁になるように適宜空白を挿入せよ．
  カプレカ―変換後の自然数が495になった段階で，プログラムを終了せよ．
  3桁よりも大きい値の場合は，ERROR!と表示して終了
  0または桁の数字が同じもの（111,222,…,999）の場合は，ERROR!と表示して終了
  各表示は標準出力に書き出し，末尾には改行文字\nを付けること．
  #include していいのは <stdio.h>のみとする．
*/

#include<stdio.h>

int main(){
  int a;
  int d[4];
  int cap=0;
  int max, min;

  scanf("%d", &cap);
  if(cap==0 || cap>=1000){
    printf("ERROR!");
  }else{
    d[2]=cap/100;
    d[1]=(cap-d[2]*100)/10;
    d[0]=cap-d[2]*100-d[1]*10;
  }

  while(1){
    for(int j=2; j>0; j--){
      for(int i=0; i<j; i++){
        if(d[i]>d[i+1]){
          d[4]=d[i+1];
          d[i+1]=d[i];
          d[i]=d[4];
        }
      }
    }
    max=d[2]*100+d[1]*10+d[0];
    min=d[0]*100+d[1]*10+d[2];
    cap=max-min;
    if(cap==0){
      printf("ERROR!");
      return 0;
    }
    printf("%d-%d=%d\n", max, min, cap);
    if(cap==495){
      break;
    }
    d[2]=cap/100;
    d[1]=(cap-d[2]*100)/10;
    d[0]=cap-d[2]*100-d[1]*10;
  }
  return 0;
}